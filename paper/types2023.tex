% easychair.tex,v 3.5 2017/03/15

\documentclass{easychair}
%\documentclass[EPiC]{easychair}
%\documentclass[EPiCempty]{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

\usepackage{doc}

% use this if you have a long article and want to create an index
% \usepackage{makeidx}

\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  escapeinside={*'}{'*},
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\color{ForestGreen},
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
  morecomment=[l]\%,
}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
% In order to save space or manage large tables or figures in a
% landcape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% Some of our commands for this guide.
%
\newcommand{\easychair}{\textsf{easychair}}
\newcommand{\miktex}{MiK{\TeX}}
\newcommand{\texniccenter}{{\TeX}nicCenter}
\newcommand{\makefile}{\texttt{Makefile}}
\newcommand{\latexeditor}{LEd}


\newcommand{\LayeredTypes}{\textsc{LayeredTypes}}
%\makeindex

%% Front Matter
%%
% Regular title as in the article class.
%
\title{LayeredTypes -- Independently combine type systems}

% Authors are joined by \and. Their affiliations are given by \inst, which indexes
% into the list defined using \institute
%
\author{
Author 1\inst{1}
\and
Author 2\inst{2}
}

% Institutes for affiliations are also joined by \and,
\institute{
  Institute 1,
  Location 1\\
  \email{mail1}
\and
   Intitute 2,
   Location 2\\
   \email{mail2}\\
}

%  \authorrunning{} has to be set for the shorter version of the authors' names;
% otherwise a warning will be rendered in the running heads. When processed by
% EasyChair, this command is mandatory: a document without \authorrunning
% will be rejected by EasyChair

\authorrunning{Authorrunning}

% \titlerunning{} has to be set to either the main title or its shorter
% version for the running heads. When processed by
% EasyChair, this command is mandatory: a document without \titlerunning
% will be rejected by EasyChair
\titlerunning{Layered Types}

\begin{document}

\maketitle



% The table of contents below is added for your convenience. Please do not use
% the table of contents if you are preparing your paper for publication in the
% EPiC Series or Kalpa Publications series

%\setcounter{tocdepth}{2}
%{\small
%\tableofcontents}

%\section{To mention}
%
%Processing in EasyChair - number of pages.
%
%Examples of how EasyChair processes papers. Caveats (replacement of EC
%class, errors).

%------------------------------------------------------------------------------
%\section{Context}
\label{sec:context}
Most programmers and computer scientists will be familiar with simple type systems that ensure that the code they write are type safe in the context of the language they are writing it in. However, much more sophisticated type systems exist that can be used to ensure specific properties of a program. For example Session Types \cite{session} can be used to show correctness of concurrent programs, linear type systems \cite{linear} ensure that objects are used exactly once and Refinement Types \cite{refinement} can narrow types by imposing predicates onto them. Another example is the use of liquid types to show bounds on resource usage \cite{liquidate-assets}.

Depending on the specific type systems, they can be viewed as independently and orthogonal from one another, however sometimes type systems also depend on other type systems and thus extending them. One example of this are refinement types which build on top of traditional type systems and extend these types by making them more specific. Most importantly not all type systems are useful for any program; When developing some low-level code meant to be run in an operating systems' kernel, they might want to use the help of a specific type system that ensure that they do not exceed certain bounds in memory usage. However, when developing an application that is meant to be run in a highly distributed environment, using Session Types might be a more appropriate type system to ensure the correct implementation of the communication of the distirbuted components.

%\section{Challenges in Type Systems}
\label{sec:challenges-in-type-systems}
Most commonly used programming languages such as Java, C++ or Haskell embed a single type system that checks, either statically or dynamically, that functions and variables are used in a compatible way. To use more sophisticated type systems such as Liquid Types, one has to rely on specific tools or compiler extensions such as LiquidHaskell\cite{LiquidHaskell} or LiquidJava\cite{LiquidJava}. This leads to the issue that it is usually not trivially possible to combine different type systems in a single program. However in some cases one might require multiple different type systems to ensure different properties of a program.

Consider the very simple code example in \autoref{lst:code_before} that reads the text contents of a file and prints it to the console line-by-line. Even in this short example there are multiple different concerns to be addressed:
\begin{itemize}
	\item From a type-safety perspective, one wants to make sure that e.g. \texttt{get(...)} is only called with a list and an integer index as arguments
	\item Additionally, one wants to ensure that \texttt{get} is never accessed with an index that exceeds the lists length to avoid out-of-bounds access errors at runtime
	\item When working with resources such as file descriptors one wants to ensure that these are in a proper (closed) state by the end of the program execution
\end{itemize}
Optimally, these properties should be verified independently from each other wherever possible. For example tracking the state of a resource can be done independently of it's specific type, so in case that for whatever reason this check fails we still want to be able to independently verify whether or not the state behaves as we intend it.

\begin{minipage}{0.4\linewidth}
\begin{lstlisting}[caption={Simple example code},label={lst:code_before}]
printLines lines idx len {
  if len != idx then {
    line = get(lines, idx)
    print(line)
    printLines(lines, idx+1, len)
  }
}

filename = "input.txt"
fileDescriptor = createFD(filename)

open(fileDescriptor)

lines = readLines(fileDescriptor)
len = length(lines)
printLines(lines, 0, len)

close(fileDescriptor)
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.59\linewidth}
\begin{lstlisting}[caption={Annotations for \LayeredTypes},label={lst:code_after}]
-- State Layer definitions
createFD :: state :: {} -> { Closed }
openFile :: state :: {Closed => Open} -> {}
readLines :: state :: {Open => Consumed} -> {}
closeFile :: state :: {Consumed => Closed} -> {}

-- Type layer definitions
get :: types :: List -> int -> string
length :: types :: List -> int
createFD :: types :: string -> FileHandle
open :: types :: FileHandle -> void
readLines :: types :: FileHandle -> List
close :: types :: FileHandle -> void
print :: types :: string -> void
printLines :: types :: List -> int -> int -> void

-- Liquid layer definitions
length :: {List | true} -> {v:int | v>=0}
printLines :: liquid :: { List | true } -> { l:int | l>=0 } -> { i:int | i<=l }
get :: liquid :: { List | true } -> { i:int | i<len }

-- State requirement at the end of the program
fileDescriptor :: state :: {Closed}	
\end{lstlisting}
\end{minipage}

A very similar issue can also be observed when operating on Liquid Types: In certain cases we want to define predicates on orthogonal properties that could be verified independently from one another; However, current implementation of liquid types do not allow us to define distinct predicates to be verified independently. In such cases we have to merge all relevant properties into one joint predicate which can make it hard to identify the specific issue when the verification fails.

%\section{Proposed Approach}
\label{sec:proposed-approach}

To tackle these issues, we present \LayeredTypes. In our approach we view different type systems as indepent layers that can be verified in an incremental way. Layers can either verify properties in a complete stand-alone matter, or they can define dependencies to other layers which allow to build more complex type systems in an incremental manner.

We want to note an important distinction to Gradual Typing\cite{gradual}: While the latter is concerned with only providing partial typing information and making it gradually more precise, our approach does not focus on the information provided to the verifier, but rather on \textit{how} this informati.

In our work we present a python-based demonstration framework that implements this layered verification approach. In a similar manner to passes in compilers, users can provide their own implementations for verification layers that suit their workflow. In \autoref{lst:code_after} we see a set of annotations that can be added to the base code of \autoref{lst:code_before} to tackle the issues described. We define three separate layers \texttt{State}, \texttt{types} and \texttt{liquid}. Our framework will build a dependency graph of the layers which allows the type "path" to be verified independently from the state path.

During our work we implemented two specific use-cases, one similar to the code snippet presented above and one using multiple liquid layers to verify different liquid properties independently.


%------------------------------------------------------------------------------

%------------------------------------------------------------------------------
\end{document}

