% easychair.tex,v 3.5 2017/03/15

\documentclass{easychair}
%\documentclass[EPiC]{easychair}
%\documentclass[EPiCempty]{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

\usepackage{doc}

% use this if you have a long article and want to create an index
% \usepackage{makeidx}

\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  escapeinside={*'}{'*},
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\color{ForestGreen},
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
  morecomment=[l]\%,
}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
% In order to save space or manage large tables or figures in a
% landcape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% Some of our commands for this guide.
%
\newcommand{\easychair}{\textsf{easychair}}
\newcommand{\miktex}{MiK{\TeX}}
\newcommand{\texniccenter}{{\TeX}nicCenter}
\newcommand{\makefile}{\texttt{Makefile}}
\newcommand{\latexeditor}{LEd}


\newcommand{\LayeredTypes}{\textsc{LayeredTypes}}
%\makeindex

%% Front Matter
%%
% Regular title as in the article class.
%
\title{LayeredTypes -- Independently combine type systems}

% Authors are joined by \and. Their affiliations are given by \inst, which indexes
% into the list defined using \institute
%
\author{
Author 1\inst{1}
\and
Author 2\inst{2}
}

% Institutes for affiliations are also joined by \and,
\institute{
  Institute 1,
  Location 1\\
  \email{mail1}
\and
   Intitute 2,
   Location 2\\
   \email{mail2}\\
}

%  \authorrunning{} has to be set for the shorter version of the authors' names;
% otherwise a warning will be rendered in the running heads. When processed by
% EasyChair, this command is mandatory: a document without \authorrunning
% will be rejected by EasyChair

\authorrunning{Authorrunning}

% \titlerunning{} has to be set to either the main title or its shorter
% version for the running heads. When processed by
% EasyChair, this command is mandatory: a document without \titlerunning
% will be rejected by EasyChair
\titlerunning{Layered Types}


\begin{document}
\maketitle



% The table of contents below is added for your convenience. Please do not use
% the table of contents if you are preparing your paper for publication in the
% EPiC Series or Kalpa Publications series

%\setcounter{tocdepth}{2}
%{\small
%\tableofcontents}

%\section{To mention}
%
%Processing in EasyChair - number of pages.
%
%Examples of how EasyChair processes papers. Caveats (replacement of EC
%class, errors).

%------------------------------------------------------------------------------
\section{Context}
\label{sec:context}
Most programmers and computer scientists will be familiar with simple type systems that ensure that the code they write are type safe in the context of the language they are writing it in. However, much more sophisticated type systems exist that can be used to ensure specific properties of a program. Examples for this are Session Types \cite{session}, used for concurrent programs, linear type systems \cite{linear} or Refinement Types \cite{refinement}.

Depending on the specific type systems, they can be viewed as independently and orthogonal from one another, however sometimes type systems can also extend existing ones such as refinement types which build on top of traditional type systems and make these more specific. Most importantly not all type systems are useful for any program; When developing some low-level code meant to be run in an operating systems' kernel, they might want to use the help of a specific type system that ensure that they do not exceed certain bounds in memory usage such as shown in \cite{liquidate-assets}. However, when developing an application that is meant to be run in a highly distributed environment, using Session Types might be a more appropriate type system to ensure the correct implementation of the communication of the distributed components.

\section{Challenges in Type Systems}
\label{sec:challenges-in-type-systems}
Most commonly used programming languages such as Java, C++ or Haskell embed a single type system that checks, either statically or dynamically, that functions and variables are used in a compatible way. To use more sophisticated type systems such as Liquid Types, one has to rely on specific tools or compiler extensions such as LiquidHaskell\cite{LiquidHaskell} or LiquidJava\cite{LiquidJava}. This leads to the issue that it is usually not trivially possible to combine different type systems in a single program. However in some cases one might require multiple different type systems to ensure different properties of a program.

Consider the simple code example in \autoref{lst:code_before} that reads the text contents of a file and prints it to the console line-by-line. In this short snippet, there are multiple concerns to be addressed. Firstly, one wants to ensure that all function calls are done with variables of the appropriate data types. Secondly, to avoid errors due to an out of bound access, \texttt{get} should only be called with an index that exceeds the list length. Lastly, when working with resources such as a file descriptor it might be useful to track it's state and ensure that it is in a proper (closed) state at the end of program execution.
%\begin{itemize}
%	\item From a type-safety perspective, one wants to make sure that e.g. \texttt{get(...)} is only called with a list and an integer index as arguments
%	\item Additionally, one wants to ensure that \texttt{get} is never accessed with an index that exceeds the lists length to avoid out-of-bounds access errors at runtime
%	\item When working with resources such as file descriptors one wants to ensure that these are in a proper (closed) state by the end of the program execution
%\end{itemize}

Optimally, these properties should be verified independently from each other wherever possible. For example tracking the state of a resource can be done independently of it's specific type, so in case that for whatever reason this check fails we still want to be able to independently verify whether or not the state behaves as we intend it.

\begin{minipage}{0.4\linewidth}
\begin{lstlisting}[caption={Simple example code},label={lst:code_before}]
printLines lines idx len {
  if len != idx then {
    line = get(lines, idx)
    print(line)
    printLines(lines, idx+1, len)
  }
}

filename = "input.txt"
fileDescriptor = createFD(filename)

open(fileDescriptor)

lines = readLines(fileDescriptor)
len = length(lines)
printLines(lines, 0, len)

close(fileDescriptor)
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.59\linewidth}
\begin{lstlisting}[caption={Annotations for \LayeredTypes},label={lst:code_after}]
-- State Layer definitions
createFD :: state :: {} -> { Closed }
openFile :: state :: {Closed => Open} -> {}
readLines :: state :: {Open => Consumed} -> {}
closeFile :: state :: {Consumed => Closed} -> {}

-- Type layer definitions
get :: types :: List -> int -> string
length :: types :: List -> int
createFD :: types :: string -> FileHandle
open :: types :: FileHandle -> void
readLines :: types :: FileHandle -> List
close :: types :: FileHandle -> void
print :: types :: string -> void
printLines :: types :: List -> int -> int -> void

-- Liquid layer definitions
length :: {List | true} -> {v:int | v>=0}
printLines :: liquid :: { List | true } -> { l:int | l>=0 } -> { i:int | i<=l }
get :: liquid :: { List | true } -> { i:int | i<len }

-- State requirement at the end of the program
fileDescriptor :: state :: {Closed}	
\end{lstlisting}
\end{minipage}

A very similar issue can also be observed when operating on Liquid Types: In certain cases we want to define predicates on orthogonal properties that could be verified independently from one another; However, current implementation of liquid types do not allow us to define distinct predicates to be verified independently. In such cases we have to merge all relevant properties into one joint predicate which can make it hard to identify the specific issue when the verification fails.

\section{Proposed Approach}
\label{sec:proposed-approach}

To tackle these issues, we present \LayeredTypes. In our approach we view different type systems as indepent layers that can be verified in an incremental way. Layers can either verify properties in a complete stand-alone matter, or they can define dependencies to other layers which allow to build more complex type systems.

We want to note an important distinction to Gradual Typing\cite{gradual}\cite{gradual-objects}: While the latter is concerned with only providing partial typing information and making it gradually more precise, our approach does not focus on the information provided to the verifier, but rather on \textit{how} this information.

In our work we present a python-based demonstration framework that implements this layered verification approach. Users can provide their own implementations for verification layers and define dependencies between them. In \autoref{lst:code_after} we see a set of annotations that can be added to the base code of \autoref{lst:code_before} to tackle the issues described. We define three separate layers \texttt{state}, \texttt{types} and \texttt{liquid}. Internally, the framework will build a dependency graph thus allowing to verify properties independently from one another where appropriate.

We believe that this layered, incremental approach can help build more powerful and independent type systems while at the same time making it simpler to understand the errors that might arise during verification.


%------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{literature}

%------------------------------------------------------------------------------
\end{document}

