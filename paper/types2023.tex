% easychair.tex,v 3.5 2017/03/15

\documentclass{easychair}
%\documentclass[EPiC]{easychair}
%\documentclass[EPiCempty]{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

\usepackage{cleveref}
\usepackage{doc}

% use this if you have a long article and want to create an index
% \usepackage{makeidx}

\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  escapeinside={*'}{'*},
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\color{ForestGreen},
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
  morecomment=[l]\%,
}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
% In order to save space or manage large tables or figures in a
% landcape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% Some of our commands for this guide.
%
\newcommand{\easychair}{\textsf{easychair}}
\newcommand{\miktex}{MiK{\TeX}}
\newcommand{\texniccenter}{{\TeX}nicCenter}
\newcommand{\makefile}{\texttt{Makefile}}
\newcommand{\latexeditor}{LEd}


\newcommand{\LayeredTypes}{\textsc{LayeredTypes}}
%\makeindex

%% Front Matter
%%
% Regular title as in the article class.
%
\title{LayeredTypes -- Combining dependent and independent type systems}

% Authors are joined by \and. Their affiliations are given by \inst, which indexes
% into the list defined using \institute
%
\author{
Lukas Abelt\inst{1,2}
\and
Alcides Fonseca\inst{1}
}

% Institutes for affiliations are also joined by \and,
\institute{
  LASIGE,
  Faculdade de CiÃªncias da Universidade de Lisboa, Portugal\\
  \email{labelt@lasige.di.fc.ul.pt},
  \email{alcides@ciencias.ulisboa.pt}
\and
   Saarland University,
   Germany\\
}

%  \authorrunning{} has to be set for the shorter version of the authors' names;
% otherwise a warning will be rendered in the running heads. When processed by
% EasyChair, this command is mandatory: a document without \authorrunning
% will be rejected by EasyChair

\authorrunning{Authorrunning}

% \titlerunning{} has to be set to either the main title or its shorter
% version for the running heads. When processed by
% EasyChair, this command is mandatory: a document without \titlerunning
% will be rejected by EasyChair
\titlerunning{Layered Types}


\begin{document}
\maketitle



% The table of contents below is added for your convenience. Please do not use
% the table of contents if you are preparing your paper for publication in the
% EPiC Series or Kalpa Publications series

%\setcounter{tocdepth}{2}
%{\small
%\tableofcontents}

%\section{To mention}
%
%Processing in EasyChair - number of pages.
%
%Examples of how EasyChair processes papers. Caveats (replacement of EC
%class, errors).

%------------------------------------------------------------------------------
\section{Context}
\label{sec:context}
Most programmers and computer scientists will be familiar with simple type systems that ensure that the code they write is type safe in the context of the language they are writing it in. However, much more sophisticated type systems exist that can be used to ensure specific properties of a program, such as resource usage (Linear Types~\cite{linear}), value predicates (Liquid Types~\cite{DBLP:conf/pldi/RondonKJ08}), or correct following of a distributed protocol (Session Types~\cite{session}).

Some of these type systems can be dependent or independent from each other. Both Liquid Types and Session Types require a base type system with primitive types (such as int, bool) to exist, but they can be orthogonal to each other, as you can have a Liquid Type whose base type is int, and a Session Type that also relies on the base value being int, ignore the liquid predicate.

Given this plethora of type systems, different applications require a different subset of type systems. Not all applications require these advanced type systems (e.g., fully dependent types), trading off static guarantees for (even if short-term) productivity. Untyped languages have been popular in both web applications, scripting and data science. On the other hand, if you are writing a device driver, you will probably want to take advantage of a type system that guarantees that memory usage is constrained to a given bound~\cite{liquidate-assets}. Or if you are writing a complex, distributed protocol, you might want to take advantage of Session Types for that part of the program.

\section{Challenges in Type Systems}
\label{sec:challenges-in-type-systems}

Right now, to choose a particular type system, developers have to change programming languages, which might introduce interoperability problems with other components of their system. Furthermore, authors of new programming languages have to write extensive standard libraries in order for their language to be adopted by the masses.
 Most commonly used programming languages such as Java, C++ or Haskell embed a single type system that checks, either statically or dynamically, that functions and variables are used in a compatible way. 
 
 To use more sophisticated type systems such as Liquid Types, developers either port their programs to a different programming language, or rely on compiler plugins to add another type-checking phase, like in LiquidHaskell\cite{LiquidHaskell} or LiquidJava\cite{LiquidJava}. However, it is not clear how multiple type systems would interact in the same programming language. 
 
 \paragraph{Problem statement:} How can multiple type system co-exist in the same programming language, allowing different, valid combinations to be used in the type-checking of a program.
 
 % Alcides is here
 
 To illustrate this in a small example, consider the program in \Cref{lst:code_before} that reads the text contents of a file and prints it to the console line-by-line. In this short snippet, there are multiple concerns to be addressed. Firstly, one wants to ensure that all function calls are done with variables of the appropriate data types. Secondly, to avoid errors due to an out of bound access, \texttt{get} should only be called with an index that exceeds the list length. Lastly, when working with resources such as a file descriptor it might be useful to track it's state and ensure that it is in a proper (closed) state at the end of program execution.
 
%\begin{itemize}
%	\item From a type-safety perspective, one wants to make sure that e.g. \texttt{get(...)} is only called with a list and an integer index as arguments
%	\item Additionally, one wants to ensure that \texttt{get} is never accessed with an index that exceeds the lists length to avoid out-of-bounds access errors at runtime
%	\item When working with resources such as file descriptors one wants to ensure that these are in a proper (closed) state by the end of the program execution
%\end{itemize}

Optimally, these properties should be verified independently from each other wherever possible. For example tracking the state of a resource can be done independently of it's specific type, so in case that for whatever reason this check fails we still want to be able to independently verify whether or not the state behaves as we intend it.

\begin{minipage}{0.4\linewidth}
\begin{lstlisting}[caption={Simple example code},label={lst:code_before}]
printLines lines idx len {
  if len != idx then {
    line = get(lines, idx)
    print(line)
    printLines(lines, idx+1, len)
  }
}

filename = "input.txt"
fileDescriptor = createFD(filename)

open(fileDescriptor)

lines = readLines(fileDescriptor)
len = length(lines)
printLines(lines, 0, len)

close(fileDescriptor)
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.59\linewidth}
\begin{lstlisting}[caption={Annotations for \LayeredTypes},label={lst:code_after}]
-- State Layer definitions
createFD :: state :: {} -> { Closed }
openFile :: state :: {Closed => Open} -> {}
readLines :: state :: {Open => Consumed} -> {}
closeFile :: state :: {Consumed => Closed} -> {}

-- Type layer definitions
get :: types :: List -> int -> string
length :: types :: List -> int
createFD :: types :: string -> FileHandle
open :: types :: FileHandle -> void
readLines :: types :: FileHandle -> List
close :: types :: FileHandle -> void
print :: types :: string -> void
printLines :: types :: List -> int -> int -> void

-- Liquid layer definitions
length :: {List | true} -> {v:int | v>=0}
printLines :: liquid :: { List | true } -> { l:int | l>=0 } -> { i:int | i<=l }
get :: liquid :: { List | true } -> { i:int | i<len }

-- State requirement at the end of the program
fileDescriptor :: state :: {Closed}	
\end{lstlisting}
\end{minipage}

A very similar issue can also be observed when operating on Liquid Types: In certain cases we want to define predicates on orthogonal properties that could be verified independently from one another; However, current implementation of liquid types do not allow us to define distinct predicates to be verified independently. In such cases we have to merge all relevant properties into one joint predicate which can make it hard to identify the specific issue when the verification fails.

\section{Proposed Approach}
\label{sec:proposed-approach}

To tackle these issues, we present \LayeredTypes. In our approach we view different type systems as indepent layers that can be verified in an incremental way. Layers can either verify properties in a complete stand-alone matter, or they can define dependencies to other layers which allow to build more complex type systems.

We want to note an important distinction to Gradual Typing\cite{gradual}\cite{gradual-objects}: While the latter is concerned with only providing partial typing information and making it gradually more precise, our approach does not focus on the information provided to the verifier, but rather on \textit{how} this information.

In our work we present a python-based demonstration framework that implements this layered verification approach. Users can provide their own implementations for verification layers and define dependencies between them. In \autoref{lst:code_after} we see a set of annotations that can be added to the base code of \autoref{lst:code_before} to tackle the issues described. We define three separate layers \texttt{state}, \texttt{types} and \texttt{liquid}. Internally, the framework will build a dependency graph thus allowing to verify properties independently from one another where appropriate.

We believe that this layered, incremental approach can help build more powerful and independent type systems while at the same time making it simpler to understand the errors that might arise during verification.


%------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{literature}

%------------------------------------------------------------------------------
\end{document}

