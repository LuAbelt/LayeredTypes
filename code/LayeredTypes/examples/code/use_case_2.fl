-- Use case 2:
-- We use the layered approach to modularize a liquid type checking approach

-- Generally the idea is to realize something where we can define independent (named) liquid refinments that we can combine
-- eg like this:
-- GreaterZero = {v:Int | v > 0}
-- NonEmpty = { v: [a] | len v > 0 }
-- AllPositive = { v: [Int] | forall i. i < len v => v[i] > 0 }
-- Ordered = { v: [a] | forall i j. i < j => v[i] < v[j] }
-- Then we can combine them like this when, eg, refining a function:
-- max :: { Ordered && NonEmpty && AllPositive } -> GreaterZero
-- Each of the Ordered, NonEmpty and AllPositive refinements shall be checked independently
-- In case of a failure, we want to be able to tell which of the refinements failed

-- Using our architecture, there are two approaches to realize this:
-- Approach 1:
--      - Each Refinement is a separate layer.
--      - These individual layers simply annotate the AST with the refinement in the typecheck method
--      - There is a final layer that performs the layered type checking
--      - Alternatively, there is just a single layer that has a reserved keyword to define refinements

-- Example syntax (With separate layers for annotation):
-- def :: LiquidTypes :: Ordered = {v:Int | v > 0}
-- def :: LiquidTypes :: NonEmpty = {v:[a] | len v > 0}
-- def :: LiquidTypes :: Ordered = {v:[a] | forall i j. i < j => v[i] < v[j]}
-- def :: LiquidTypes :: AllPositive = {v:[Int] | forall i. i < len v => v[i] > 0}
-- max :: LiquidTypes :: { Ordered && NonEmpty && AllPositive } -> Positive

-- Approach 2:
--      - Each Refinement is a separate layer.
--      - We extend the framework to separate the typechecking from the annotation of the AST
--      - In the adapted framework first all annotations are performed
--      - Then the typechecking is performed by each layer independently

-- Example Syntax:
-- def :: LT-Positive :: Ordered = {v:Int | v > 0}
-- def :: LT-NonEmpty :: NonEmpty = {v:[a] | len v > 0}
-- def :: LT-Ordered :: Ordered = {v:[a] | forall i j. i < j => v[i] < v[j]}
-- def :: LT-AllPositive :: AllPositive = {v:[Int] | forall i. i < len v => v[i] > 0}

-- max :: LT-Positive :: {} -> {Positive}
-- max :: LT-NonEmpty :: {NonEmpty} -> {}
-- max :: LT-Ordered :: {Ordered} -> {}
-- max :: LT-AllPositive :: {AllPositive} -> {}

-- Alternatively, we could also implement it in a way that we define a separate layer for annotating refinements to variables/functions
-- This would reduce the four last lines to a single line:
-- max :: LiquidTypes :: { Ordered && NonEmpty && AllPositive } -> Positive


-- Pros and cons of the two approaches:
-- Approach 1:
--      - Pro: No adaptation of the framework necessary
--      - Pro: Depending on the exact implementation it might be clearer which refinements are used by variables/functions
--      - Con: We basically implement a layered approach again as a separate layer
--      - Con: The typechecking layer needs to somehow collect information about the refinements/names

-- Approach 2:
--      - Pro: The responsibility of each layer stays clear
--      - Pro: No additional layer for typechecking is necessary
--      - Con: The framework needs to be adapted
--      - Con: Since each layer is responsible for its own typechecking, it might not be clear which refinements are used

-- For both approaches we will need layers that are virtually identical with only very small differences
-- Therefore it might also be useful to add some concept of "template" layers to the framework
-- Example Syntax:
-- LiquidTypes<Ordered> :: {v:Int | v > 0} -- Template instantiation of LiquidTypes Can be used for refinements with layer name "Ordered"



swap list idx1 idx2 {
    tmp := get_element(list, idx1)
    set_element(list, idx1, get_element(list, idx2))
    set_element(list, idx2, tmp)
}

bubble_up list idx {
    cond := get_element(list, idx) > get_element(list, (idx + 1))
    if cond then {
        swap(list, idx, (idx + 1))
    }

    cond := idx < len(list) - 2

    if cond then {
        list := bubble_up(list, (idx + 1))
    }

    list
}

bubbleSort_rec list maxIdx {
    cond := maxIdx > 0
    if cond then {
        list := bubble_up(list, 0)
        list := bubbleSort_rec(list, (maxIdx - 1))
    }

    list
}

bubbleSort list {
    bubbleSort_rec(list, (len(list) - 1))
}

list := get_list()

bubbleSort(list)