-- Example scenario:
-- We open a file and read it line by line
-- We want to keep track of the line number and the line itself
-- We assume that each line represents a number
-- If the line is a positive number, we want to add it to a sum
-- If the line is a negative number, we want to add it's square to a sum

-- Layer Definitions for externally defined functions
getLine :: types :: [string] -> int -> string
strToInt :: types :: string -> int

len :: types :: [string] -> int
createFD :: types :: string -> FileHandle
openFile :: types :: FileHandle -> FileHandle
readLines :: types :: FileHandle -> [string]
closeFile :: types :: FileHandle -> void
print :: types :: Any -> void

-- Layer definitions for type checking
logicalTypes :: typecheck :: bool
numTypes :: typecheck :: int
subtype :: typecheck :: int <: Any
subtype :: typecheck :: string <: Any

-- Theoretical layer definitions for a state layer
-- 1. Open - The file is open and can be read from
-- 2. Consumed - The file has been read from and can no longer be read from, but still open
-- 3. Closed - The file is closed and cannot be read from

-- The state of a file handle can be changed by the following functions:
-- 1. openFile - Return something that has the state open
-- 2. readLines - Changes the state from Open to Consumed
-- 3. closeFile - Changes the state from Consumed to Closed

-- Layer definitions could look as following:
-- openFile takes something without a state and returns something with state "Open"
createFD :: state :: {} -> { Closed }
openFile :: state :: {Closed => Open} -> {}
-- readLines takes something with state "Open" and returns something with state "Consumed"
readLines :: state :: {Open => Consumed} -> {}
-- closeFile takes something with state "Consumed" and returns something with state "Closed"
closeFile :: state :: {Consumed => Closed} -> {}

-- Recursive process line that is called in order to process each line
processLine :: types :: [string] -> int -> int -> int
processLine lines idx length {

    end :: types :: bool
    end := idx == length

    if end then {
        0
    } else {

        -- getLine externally defined in python
        curLine :: types :: string
        curLine := getLine(lines, idx)

        -- Convert the line to an integer
        number :: types :: int
        number := strToInt(curLine)

        -- If the number is positive, we add it to the sum
        greaterThanZero :: types :: bool
        greaterThanZero := number > 0

        if greaterThanZero then {
            number + processLine(lines, idx + 1, length)
        } else {
            -- If the number is negative, we add it's square to the sum
            (number * number) + processLine(lines, idx + 1, length)
        }

    }
}

processLines :: types :: [string] -> int
processLines lines {
    -- We use the external len function from python
    length :: types :: int
    length := len(lines)

    idx :: types :: int
    idx := 0
    processLine(lines, idx, length)
}

fileName :: types :: string
fileName := "numbers.data"

fileDescriptor :: types :: FileHandle
fileDescriptor := createFD(fileName)

-- We use the external readFile function from python
openFile(fileDescriptor)

-- We use the externally defined readline
lines :: types :: [string]
lines := readLines(fileDescriptor)

closeFile(fileDescriptor)

total :: types :: int
total := processLines(lines)

print(total)
total

-- State post-conditions
-- The file handle is closed after the program has finished
fileDescriptor :: state :: {Closed}