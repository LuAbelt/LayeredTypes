-- This is a variation of use case 2
-- Here we will separate concerns into three different layers:
-- 1. The row layer - operations that only depend on the number of rows
-- 2. The column layer - operations that only depend on the number of columns
-- 3. The row-column layer - operations that depend on both the number of rows and columns

-- Get Dimensions of a Data Set
n_rows :: rows :: { d:DataSet | true } -> { r:Int | (r >= 0) && (r == (n_rows(d)) }
n_cols :: rows :: { d:DataSet | true } -> { c:Int | true }

n_rows :: cols :: { d:DataSet | true } -> { r:Int | true }
n_cols :: cols :: { d:DataSet | true } -> { c:Int | (c >= 0) && (c == (n_cols(d)) }

n_rows :: rowcol :: { d:DataSet | true } -> { r:Int | (r >= 0) && (r == (n_rows(d)) }
n_cols :: rowcol :: { d:DataSet | true } -> { c:Int | (c >= 0) && (c == (n_cols(d)) }

-- Add rows or columns to a data set
add_rows :: rows :: { d:DataSet | true } -> {n:Int | n>0} -> { d2:DataSet | (n_rows(d2) == (n_rows(d) + n)) }
get_row :: rows :: { d:DataSet | true } -> { r:Int | (r >= 0) && (r < (n_rows(d))) } -> { d2:DataSet | (n_cols(d2) == (n_cols(d)) && (n_rows(d2)==1) ) }
sample :: rows :: { d:DataSet | true } -> { n:Int | (n >= 0) && (n <= (n_rows(d))) } -> { d2:DataSet | (n_rows(d2) == n) }

add_rows :: cols :: { d:DataSet | n_cols(d) > 0 } -> { n:Int | true } -> { d2:DataSet | ( n_cols(d2) == n_cols(d) ) }
get_row :: cols :: { d:DataSet | n_cols(d) > 0 } -> { r:Int | true } -> { d2:DataSet | ( n_cols(d2) == n_cols(d) ) }
sample :: cols :: { d:DataSet | n_cols(d) > 0 } -> { n:Int | true } -> { d2:DataSet | ( n_cols(d2) == n_cols(d) ) }

add_rows :: rowcol :: { d:DataSet | true } -> { n:Int | true } -> { d2:DataSet | ( n_cols(d2) == n_cols(d) ) && ( n_rows(d2) == (n_rows(d) + n) ) }
get_row :: rowcol :: { d:DataSet | true } -> { r:Int | true } -> { d2:DataSet | ( n_cols(d2) == n_cols(d) ) && ( n_rows(d2) == 1 ) }
sample :: rowcol :: { d:DataSet | true } -> { n:Int | true } -> { d2:DataSet | ( n_cols(d2) == n_cols(d) ) && ( n_rows(d2) == n ) }

-- Perform operations that depend on the number of columns
add_cols :: cols :: { d:DataSet | true } -> {n:Int | n>0} -> { d2:DataSet | (n_cols(d2) == (n_cols(d) + n)) }
extract_col :: cols :: { d:DataSet | true } -> { c:Int | (c >= 0) && (c < (n_cols(d))) } -> { d2:DataSet | (n_cols(d2) == 1) }
reduce_cols :: cols :: { d:DataSet | true } -> { c:Int | (c >= 0) && (c < (n_cols(d))) } -> { d2:DataSet | (n_cols(d2) == c) }

add_cols :: rows :: { d:DataSet | true } -> {n:Int | true } -> { d2:DataSet | (n_rows(d2) == n_rows(d) ) }
extract_col :: rows :: { d:DataSet | true } -> { c:Int | true } -> { d2:DataSet | (n_rows(d2) == n_rows(d) ) }
reduce_cols :: rows :: { d:DataSet | true } -> { c:Int | true } -> { d2:DataSet | (n_rows(d2) == n_rows(d) ) }

add_cols :: rowcol :: { d:DataSet | true } -> {n:Int | true } -> { d2:DataSet | (n_cols(d2) == (n_cols(d) + n)) && (n_rows(d2) == n_rows(d)) }
extract_col :: rowcol :: { d:DataSet | true } -> { c:Int | true } -> { d2:DataSet | (n_cols(d2) == 1) && (n_rows(d2) == n_rows(d)) }
reduce_cols :: rowcol :: { d:DataSet | true } -> { c:Int | true } -> { d2:DataSet | (n_cols(d2) == c) && (n_rows(d2) == n_rows(d)) }

-- When training a model, we should have at least 10 rows per column
train :: rowcols :: { d:DataSet | (n_rows(d) >= 10 * (n_cols(d))) } -> { m:Model | true }

create_empty_dataset :: cols :: { n:Int | (n >= 0) } -> { d:DataSet | (n_cols(d) == n) }
create_empty_dataset :: rows :: { n:Int | (n >= 0) } -> { d:DataSet | (n_rows(d) == 0) }
create_empty_dataset :: rowcol :: { n:Int | (n >= 0) } -> { d:DataSet | (n_rows(d) == 0) && (n_cols(d) == n) }

-- Scenario 1: Operations with only rows

let empty_dataset := create_empty_dataset(10) in {
    let dataset := add_rows(empty_dataset, 50) in {
        let row := get_row(dataset, 17) in {
            row
        }

        -- This fails because we do not have enough rows
        let row := get_row(dataset, 100) in {
            row
        }

        -- This fails because we do not have enough rows
        let s := sample(dataset, 100) in {
            s
        }

        let s := sample(dataset, 10) in {
            s
        }
    }
}

-- Scenario 2: Operations with only columns

let empty_dataset := create_empty_dataset(10) in {
    let dataset := add_cols(empty_dataset, 50) in {
        let c := extract_col(dataset, 7) in {
            c
        }

        let c := extract_col(dataset, 10) in {
            c
        }

        let c := reduce_cols(dataset, 5) in {
            c
        }

        let c := reduce_cols(dataset, 100) in {
            c
        }
    }
}

-- Scenario 3: Operations with rows and columns
-- We show that calling train on this data set fails because we do not have enough rows

let empty_dataset := create_empty_dataset(10) in {
    let dataset := add_rows(empty_dataset, 50) in {
       train(dataset)

       let single_column := extract_col(dataset, 5) in {
           train(single_column)
       }

       let small_dataset := reduce_cols(dataset, 5) in {
           train(small_dataset)
       }
    }
}

